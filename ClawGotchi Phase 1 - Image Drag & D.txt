ClawGotchi Phase 1 - Image Drag & Drop

 Context

 Phase 0 완료: 투명 always-on-top 캐릭터, OpenClaw 채팅, 말풍선, 양피지(별도 윈도우), 드래그, 시스템 트레이.

 Phase 1 목표: 이미지를 캐릭터에 드래그 & 드롭하면 이미지와 함께 질문을 보낼 수 있는 기능. 윈도우 탐색기, 브라우저 다운로드, 웹 브라우저 이미지 직접 드래그 모두 지원.

 ---
 OpenClaw 이미지 전송 규격

 OpenClaw chat.send에서 이미지는 message(항상 string)과 별도의 attachments 배열로 전송:

 await client.request("chat.send", {
   sessionKey,
   message: "이 이미지에 뭐가 있어?",       // 항상 plain string
   deliver: false,
   idempotencyKey: runId,
   attachments: [                             // 이미지는 여기!
     { type: "image", mimeType: "image/png", content: "<raw-base64>" }
   ],
 });

 서버 검증: base64 유효성, 5MB 제한, MIME 스니핑.

 ---
 핵심 기술 결정: HTML5 Drag & Drop

 Tauri의 네이티브 onDragDropEvent는 로컬 파일 경로만 제공하고, 웹 브라우저 이미지 드래그는 처리 불가.
 HTML5 drag events는 세 가지 소스 모두 처리 가능:

 ┌───────────────────────┬────────────────────────────────────┬────────────────────────────┐
 │         소스          │         HTML5 dataTransfer         │         처리 방식          │
 ├───────────────────────┼────────────────────────────────────┼────────────────────────────┤
 │ 윈도우 탐색기         │ files (File 객체)                  │ FileReader.readAsDataURL() │
 ├───────────────────────┼────────────────────────────────────┼────────────────────────────┤
 │ 브라우저 다운로드     │ files (File 객체)                  │ FileReader.readAsDataURL() │
 ├───────────────────────┼────────────────────────────────────┼────────────────────────────┤
 │ 웹 이미지 직접 드래그 │ text/html 또는 text/uri-list (URL) │ Rust 커맨드로 URL fetch    │
 └───────────────────────┴────────────────────────────────────┴────────────────────────────┘

 설정: tauri.conf.json에서 "dragDropEnabled": false → HTML5 이벤트 활성화

 ---
 수정할 파일

 1. src-tauri/tauri.conf.json

 - main 윈도우에 "dragDropEnabled": false 추가
 - CSP img-src에 blob: 추가 (이미지 프리뷰용)

 2. src-tauri/src/lib.rs

 - fetch_image_url Rust 커맨드 추가 (브라우저 이미지 URL → bytes 다운로드)
 - generate_handler!에 새 커맨드 등록

 3. src-tauri/Cargo.toml

 - reqwest = { version = "0.12", features = ["blocking"] } 추가 (URL fetch용)

 4. src/store/useStore.ts

 - attachedImage: { dataUrl: string; mimeType: string } | null 상태 추가
 - setAttachedImage(img) / clearAttachedImage() 액션 추가

 5. src/hooks/useDrop.ts (신규)

 - HTML5 dragover, dragleave, drop 이벤트 리스너
 - 드롭 시 세 가지 소스 분기:
   - File 객체 → FileReader.readAsDataURL() → store에 저장
   - URL → invoke("fetch_image_url", { url }) → base64 변환 → store에 저장
 - 이미지 타입 필터링 (png, jpg, jpeg, gif, webp)
 - 드래그 중 시각적 피드백 (dragOver 상태)
 - 연결 안 된 상태/양피지 열린 상태에서는 무시

 6. src/components/ChatInput.tsx

 - 이미지 첨부 시 자동으로 입력창 열기
 - 이미지 프리뷰 표시 (썸네일 + X 삭제 버튼)
 - handleSubmit에서 attachments 배열 구성하여 전송
 - base64 추출: dataUrl.split(",")[1]
 - 이미지만 전송 (텍스트 없이 엔터)도 허용

 7. src/components/ChatInput.css

 - .chat-image-preview 스타일 (작은 썸네일, X 버튼)

 8. src/App.tsx

 - useDrop() 훅 호출
 - 드래그 중 시각적 피드백 (캐릭터 주변 하이라이트)

 ---
 UI 흐름

 1. 사용자가 이미지를 캐릭터 윈도우에 드래그
 2. 캐릭터 주변에 드롭 가능 표시 (테두리 하이라이트)
 3. 드롭하면 이미지가 store에 저장되고 ChatInput이 자동으로 열림
 4. ChatInput 위에 작은 이미지 썸네일 + X(삭제) 버튼 표시
 5. 사용자가 텍스트 입력 후 Enter → 이미지 + 텍스트가 OpenClaw에 전송
 6. 전송 후 attachedImage 클리어

 ---
 구현 순서

 Step 1: Tauri 설정 변경

 - tauri.conf.json: dragDropEnabled: false, CSP에 blob: 추가
 - Cargo.toml: reqwest 의존성 추가

 Step 2: fetch_image_url Rust 커맨드

 - URL을 받아 HTTP GET → bytes → base64 반환
 - MIME type 감지 (Content-Type 헤더 또는 확장자)
 - lib.rs에 등록

 Step 3: Zustand store 확장

 - attachedImage 상태 + 액션 추가

 Step 4: useDrop 훅

 - HTML5 drag/drop 이벤트 전체 처리
 - 세 가지 이미지 소스 (파일, URL, HTML) 처리
 - store에 이미지 저장 + ChatInput 자동 열기

 Step 5: ChatInput UI 수정

 - 이미지 프리뷰 + X 삭제 버튼
 - handleSubmit에서 attachments 포함 전송

 Step 6: 드래그 시각 피드백

 - App.tsx에서 useDrop의 isDragOver 상태로 하이라이트 표시

 ---
 검증

 1. 탐색기 드래그: 로컬 PNG/JPG를 캐릭터에 드래그 → 프리뷰 표시 → 질문 입력 → 전송 → AI 응답
 2. 브라우저 다운로드 드래그: Chrome 다운로드 바에서 이미지를 드래그 → 동작 확인
 3. 웹 이미지 드래그: 웹페이지의 이미지를 직접 드래그 → URL fetch → 동작 확인
 4. X 버튼: 이미지 삭제 후 일반 텍스트만 전송
 5. 큰 이미지: 5MB 초과 이미지 → 에러 메시지
 6. 비이미지 파일: txt, pdf 등 → 무시